<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Academic publishing careers in NL: gathering ethnicity</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Independent variables
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="names.html">Names</a>
    </li>
    <li>
      <a href="gender.html">Gender</a>
    </li>
    <li>
      <a href="ethnicity.html">Ethnicity</a>
    </li>
    <li>
      <a href="discipline.html">Discipline</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Dependent variables
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="datapreparation.html">Starting and stopping to publish</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Descriptives
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="table1.html">Table 1</a>
    </li>
    <li>
      <a href="table2.html">Table 2</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analyses
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="starting_analyses.html">Analyses 'starting to publish'</a>
    </li>
    <li>
      <a href="stopping_analyses.html">Analyses 'stopping to publish'</a>
    </li>
  </ul>
</li>
<li>
  <a href="figures.html">Figures</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Appendices
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="splines.html">Splines</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/ammulders/amatteroftime">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Academic publishing careers in NL:
gathering ethnicity</h1>
<h4 class="date">Last compiled on februari, 2024</h4>

</div>


<!---please be aware that caching large objects is problematic, hence cache.lazy=FALSE and you may need to turn cache=FALSE for chuncks in which you load large datasets --->
<hr />
<p>We determine ethnic backgrounds based on last names. For this, we use
information from three sources:</p>
<ol style="list-style-type: decimal">
<li><p>Data on the origin of last names, web scraped from the <a
href="https://www.cbgfamilienamen.nl/nfb/">Nederlandse
Familienamenbank</a></p></li>
<li><p>A list of common Moroccan names</p></li>
<li><p>Birth countries listed in dissertation PDFs</p></li>
</ol>
<hr />
<div id="custom-functions" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Custom functions</h1>
<ul>
<li><code>fpackage.check</code>: Check if packages are installed (and
install if not) in R (<a
href="https://vbaliga.github.io/verify-that-r-packages-are-installed-and-loaded/">source</a>).</li>
</ul>
<pre class="r test"><code>rm(list = ls())


fpackage.check &lt;- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave &lt;- function(x, file, location = &quot;./data/processed/&quot;) {
    datename &lt;- substr(gsub(&quot;[:-]&quot;, &quot;&quot;, Sys.time()), 1, 8)
    totalname &lt;- paste(location, datename, file, sep = &quot;&quot;)
    save(x, file = totalname)
}</code></pre>
<hr />
</div>
<div id="packages" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Packages</h1>
<ul>
<li><p><code>tidyverse</code>: For general data manipulaion</p></li>
<li><p><code>stringr</code>: for string manipulations</p></li>
<li><p><code>dplyr</code>: for data manipulation</p></li>
<li><p><code>rvest</code>: for</p></li>
</ul>
<pre class="r test"><code>packages = c(&quot;tidyverse&quot;, &quot;stringr&quot;, &quot;dplyr&quot;, &quot;rvest&quot;, &quot;stringi&quot;, &quot;forcats&quot;)

fpackage.check(packages)</code></pre>
<hr />
</div>
<div id="input" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Input</h1>
<p>We use two processed datasets</p>
<ul>
<li><a
href="https://github.com/ammulders/amatteroftime/data/processed/phdnames.rda">phdnames.rda</a>:
example dataset of 8 (fictional) PhDs with first and last names
<ul>
<li>For construction of this dataset see <a
href="names.html">Independent variables: names</a><br />
</li>
<li>name of dataset: <code>phdnames</code></li>
</ul></li>
<li><a
href="https://github.com/ammulders/amatteroftime/data/processed/lastname_origin.rda">lastname_origin.rda</a>:
web scraped ethnicity data for the 8 last names in the example data from
de Nederlandse Familienamenbank
<ul>
<li>name of dataset: <code>gender</code></li>
</ul></li>
</ul>
<pre class="r test"><code>load(file = &quot;./data/processed/phdnames.rda&quot;)

load(file = &quot;./data/processed/lastname_origin.rda&quot;)</code></pre>
<hr />
</div>
<div id="method-1-familienamenbank-last-name-origin"
class="section level1" number="4">
<h1><span class="header-section-number">4</span> Method 1:
Familienamenbank last name origin</h1>
<p>The primary determinant for ethnicity is <a
href="https://www.cbgfamilienamen.nl/nfb/">de Nederlandse
Familienamenbank</a>(hereafter “Familienamenbank”). This website, like
the Meertens Voornamenbank which was used to determine researchers’
gender, uses register data from Dutch inhabitants. Specifically, the
website harbors information on the frequency, geographical spread, and
origin of 320,000 last names which occur in the Dutch register.</p>
<p>The origin information, specifically, is used to determine
researchers’ ethnicities. This information is found under the ‘analyse
en verklaring’ tab of the name page. This information is structured so
that, if names are Dutch, more detailed origins of the name are
mentioned (e.g. whether the last name originates from a certain
profession, geographical region in the Netherlands or whether it is
derived from fathers’ first names). If names are not Dutch, however,
only the country or broader region from which the name originates is
mentioned. See below for examples of these pages for a Dutch and a
non-Dutch last name.</p>
<div class="float">
<img src="misc/verschuuren_cbgf.png" alt="verschuurencbg" />
<div class="figcaption">verschuurencbg</div>
</div>
<div class="float">
<img src="misc/karimi_cbgf.png" alt="karimicbg" />
<div class="figcaption">karimicbg</div>
</div>
<p>We scraped the “analyse en verklaring” section for each of the last
names in our sample. The latter image shows that the subsection
“verklaring” and “kenmerken” provide information on the countries
associated with non-Dutch names, while “specifieke componenten” provides
more information on certain parts of the name. The resulting dataframe
for our example dataset is shown below.</p>
<pre class="r test"><code>print(lastname_origin, row.names = FALSE)</code></pre>
<div id="separating-names-with-dutch-unknown-origin"
class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Separating names with
Dutch &amp; unknown origin</h2>
<p>As mentioned earlier, it is not mentioned explicitly that Dutch names
are Dutch. Therefore, we need to identify Dutch names specifically, and
set them apart from non-Dutch names for which there is no origin
information present.</p>
<p>In short, we detect the two categories of names as follows: - Dutch
names: no label indicating that the name is Dutch, but some other
information available on name origin - Unknown names: web page cannot be
found, so origin information is completely empty.</p>
<pre class="r test"><code># Identify last names that could not be found
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(verklaring = ifelse(verklaring == &quot;&quot;, 0, verklaring), kenmerken = ifelse(kenmerken == &quot;character(0)&quot;,
        0, kenmerken), sc = ifelse(sc == &quot;character(0)&quot;, 0, sc), no_info = nchar(verklaring) + nchar(kenmerken) +
        nchar(sc))

lastname_origin &lt;- lastname_origin %&gt;%
    mutate(no_info = ifelse(no_info == 3, 1, 0), verklaring = ifelse(verklaring == 0, NA, verklaring),
        kenmerken = ifelse(kenmerken == 0, NA, kenmerken))
# If there is no text in verklaring or kenmerken, the name could not be found in the databases.</code></pre>
</div>
<div id="extracting-specific-origin-information" class="section level2"
number="4.2">
<h2><span class="header-section-number">4.2</span> Extracting specific
origin information</h2>
<p>There are three main ways to get information about the origin of last
names:</p>
<ol style="list-style-type: decimal">
<li><p>Under “kenmerken”, last names are assigned clickable tags. These
tags include unspecified foreign name tags (“andere taal”=“non-Dutch
language”), as well as specific foreign origins of the name (“Franse
naam”=“French name”, “Indische naam”=“Indonesian name”). -&gt; origin1 +
origin4</p></li>
<li><p>Several names have more extensively written out information about
the name, under “verklaring”. A number of names contain detailed (either
country-level or regional) origins, usually in the form of “De naam
[xyz] is afkomstig uit [country]” (=“The name [xyz] originates from
[country]”). -&gt; origin2</p></li>
<li><p>Some names have origin information under “verklaring” in the form
of the linguistic origins of the name. This can be country specific
(e.g. Chinese name), but it can also apply to multiple countries when
the language is spoken in more than 1 countries (e.g. Spanish name).
-&gt; origin3</p></li>
</ol>
<pre class="r test"><code># Step 1: extracting origin tags from kenmerken
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = str_extract(kenmerken, &quot;[:upper:]([:lower:]{2,}) naam&quot;))

# Note: sometimes multiple origins are mentioned. Currently, I only extract the first one.
# Otherwise, we should use str_extract_all.



# Step 2: extracting origin info from verklaring
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin2 = ifelse(as.numeric(str_detect(verklaring, &quot;afkomstig uit&quot;)) == 1, str_remove(verklaring,
        &quot;.*afkomstig uit&quot;), NA))


# Step 3: extracting additional origin info from verklaring
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin3 = str_extract(verklaring, &quot;[:upper:]([:lower:]{2,}) (achter)?(familie)?(beroeps)?naam&quot;))



# Finally, we clean up the origin information extracted above

# Origin1: already neat
lastname_origin$origin1 &lt;- str_remove(lastname_origin$origin1, &quot;Joodse naam&quot;)  # can be Dutch &amp; non-Dutch

# Origin2: messy
lastname_origin$origin2 &lt;- str_remove(lastname_origin$origin2, &quot;\\..*&quot;)  # remove extra info in the following sentence 
lastname_origin$origin2 &lt;- str_remove(lastname_origin$origin2, &quot;\\;.*&quot;)  # remove extra info in the following sentence 
lastname_origin$origin2 &lt;- str_remove(lastname_origin$origin2, &quot;\\(.*&quot;)  # remove extra info in the following sentence 


lastname_origin$dpg &lt;- as.numeric(str_detect(lastname_origin$origin2, &quot;(dorp)|(plaats)|(gemeente)|(graafschap)|(stad)|(deel)|(Friesland)&quot;))  # origin info too regional 
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin2 = ifelse((dpg == 1), NA, origin2))  # removing regional origin info
lastname_origin &lt;- subset(lastname_origin, select = -dpg)  # removing intermediate variable

# Sometimes, there were multiple countries mentioned. Take only the first:
lastname_origin$origin2 &lt;- str_remove(lastname_origin$origin2, &quot;\\,.*&quot;)  # Only first
lastname_origin$origin2 &lt;- str_remove(lastname_origin$origin2, &quot;\\s(en).*&quot;)  # Only first 
lastname_origin$origin2 &lt;- str_remove(lastname_origin$origin2, &quot;\\s(of).*&quot;)  # Only first 


# Origin3: pretty neat
lastname_origin$origin3 &lt;- str_remove(lastname_origin$origin3, &quot;D(i)?e(ze)? (familie)?(achter)?(beroeps)?naam&quot;)  # slipped through the regex
lastname_origin$origin3 &lt;- str_remove(lastname_origin$origin3, &quot;Een (familie)?(achter)?(beroeps)?naam&quot;)  # slipped through the regex
lastname_origin$origin3 &lt;- str_remove(lastname_origin$origin3, &quot;Zijn (familie)?(achter)?(beroeps)?naam&quot;)  # slipped through the regex
lastname_origin$origin3 &lt;- str_remove(lastname_origin$origin3, &quot;Als (familie)?(achter)?(beroeps)?naam&quot;)  # slipped through the regex
lastname_origin$origin3 &lt;- str_remove(lastname_origin$origin3, &quot;Joodse (familie)?(achter)?naam&quot;)
lastname_origin$origin3 &lt;- str_remove(lastname_origin$origin3, &quot;Bijbelse (familie)?(achter)?naam&quot;)


# Setting empty origin variables to NA (Dutch or unfound foreign)
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = as.character(ifelse(origin1 == &quot;&quot; | origin1 == &quot;character(0)&quot;, NA, origin1)), origin2 = as.character(ifelse(origin2 ==
        &quot;&quot; | origin2 == &quot;character(0)&quot;, NA, origin2)), origin3 = as.character(ifelse(origin3 == &quot;&quot; |
        origin3 == &quot;character(0)&quot;, NA, origin3)))



# Finally, the tag &#39;andere taal&#39; was used to distinguish foreign names of unknown origin from known
# Dutch names.
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin4 = ifelse((as.numeric(str_detect(kenmerken, &quot;andere taal&quot;)) == 1), &quot;non-Dutch&quot;, NA))</code></pre>
<p>The result is as follows:</p>
<pre class="r test"><code>lastname_origin[, c(1, 6, 7, 8, 9)]</code></pre>
</div>
<div id="combining-origin-info-from-different-sources"
class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Combining origin info
from different sources</h2>
<p>Now, we potentially have origin information from three different
sources. The final origin decision is based on how dependable and how
informative the label is. The heuristic is as follows:</p>
<ol style="list-style-type: decimal">
<li><p>Priority is given to origin information from specific country
tags (i.e. origin1), because this information is the most neat. If no
country tag is provided under origin1, we look at the geographical
origins indicated in the running text (origin 2). If this is also not
present, we take the linguistic origins of the name (origin 3)</p></li>
<li><p>If there is no specific country information, but there is a tag
for a foreign name (origin4), then the name is labelled as “unknown
non-Dutch”.</p></li>
<li><p>If there is no specific country information AND no tag for
foreign name in origin4, but there is other information about the name,
we assume the person bearing this name is Dutch.</p></li>
</ol>
<p>In sum: origin1 &gt; origin2 &gt; origin3 &gt; origin4.</p>
<pre class="r test"><code># Origin 1: specific country tags
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin = origin1)

# Origin 2: no specific country tag, take the geographical origin of the name
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin = ifelse((is.na(origin1) &amp; !is.na(origin4)), origin2, origin))

# Origin 3: neither of the above, take the linguistic origin of the name
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin = ifelse((is.na(origin1) &amp; is.na(origin2) &amp; !is.na(origin4)), origin3, origin))

# Origin 4: set to unknown non-Dutch if the name is labelled as such with no specific origin info
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin = ifelse((is.na(origin1) &amp; is.na(origin2) &amp; is.na(origin3)), origin4, origin))

# Final step: if there is no origin information present, but other background information could be
# found, the name is likely Dutch.
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin = ifelse((is.na(origin) &amp; no_info == 0), &quot;dutch&quot;, origin))

lastname_origin$origin &lt;- trimws(lastname_origin$origin, which = &quot;both&quot;)</code></pre>
<p>To construct the ethnicity variable, we distinguish five different
backgrounds: 1. Ethnic majority members (i.e. those with Dutch names) 2.
Turkish-Dutch individuals 3. Moroccan-Dutch individuals 4.
Caribbean-Dutch individuals 5. Those with a different ethnicity from
those listed above</p>
<pre class="r test"><code>lastname_origin$origin1 &lt;- lastname_origin$origin

lastname_origin &lt;- subset(lastname_origin, select = c(lastname, origin1))


# we define different ways in which ethnic minority names are identified in the &#39;Familienamenbank&#39;
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = ifelse(as.numeric(str_detect(origin1, paste(&quot;(Turkije)|(Turkse naam)&quot;))), &quot;turkish&quot;,
        origin1))

lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = ifelse(as.numeric(str_detect(origin1, paste(&quot;(Marokkaanse naam)|(Marokko)|(de Marokko)&quot;))),
        &quot;moroccan&quot;, origin1))

lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = ifelse(as.numeric(str_detect(origin1, paste(&quot;(de Nederlandse Antillen)|(Surinaamse naam)|(Suriname)&quot;))),
        &quot;carribean&quot;, origin1))

lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = ifelse((!is.na(origin1) &amp; as.numeric(str_detect(origin1, &quot;turkish|moroccan|carribean|dutch&quot;)) ==
        0), &quot;other&quot;, origin1))

lastname_origin$origin1 &lt;- as.factor(lastname_origin$origin1)


# we create an explicit &#39;missing&#39; category for those who are not categorized under ethnic majority,
# minority or &#39;other lastname_origin&#39;
lastname_origin &lt;- lastname_origin %&gt;%
    mutate(origin1 = fct_explicit_na(origin1, na_level = &quot;missing&quot;))


# thus, we get the following dataframe:
lastname_origin</code></pre>
<p>We take the last name information from origin1 as the basis for our
ethnicity variable. Hence, we make a new data frame, in which we copy
the information from origin1 to a new ‘ethnicity’ object. Next, we
enrich this ethnicity variable using information from first names and
birth places listed in dissertation PDFs.</p>
<pre class="r test"><code>phdethnicity &lt;- lastname_origin

phdethnicity$ethnicity &lt;- phdethnicity$origin1</code></pre>
</div>
</div>
<div id="method-2-moroccan-name-list" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Method 2: Moroccan name
list</h1>
<p>In addition to determining ethnicity based on last names, we look at
first names. Specifically, we use a list of Moroccan first names to
detect whether an individual is likely of Moroccan descent. Untill very
recently, first names of Moroccan individuals were regulated by Moroccan
law <span class="citation">(<strong>haskouri?</strong>)</span>. This
implies that many Moroccan individuals choose names for their children
from a list of accepted girls and boys names. We load in a list of names
by @<code>Morocco Guide</code> as an additional indicator that a PhD is
Moroccan and add this to our example data frame.</p>
<pre class="r test"><code># Adding first names back in
phdethnicity &lt;- left_join(phdnames, phdethnicity, by = &quot;lastname&quot;)


# Add the moroccan names to the ethnicity data
load(file = &quot;data/processed/moroccannames.rda&quot;)


phdethnicity &lt;- left_join(phdethnicity, moroccannames[, c(1, 3)], by = &quot;firstname&quot;)


# Add explicit missing category in origin2
phdethnicity &lt;- phdethnicity %&gt;%
    mutate(origin2 = fct_explicit_na(origin2, na_level = &quot;missing&quot;))

# We overwrite ethnicity to minority if the first name is Moroccan
for (i in 1:nrow(phdethnicity)) {
    if (phdethnicity$origin1[i] == &quot;missing&quot; &amp; phdethnicity$origin2[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    } else if (phdethnicity$origin1[i] == &quot;dutch&quot; &amp; phdethnicity$origin2[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    } else if (phdethnicity$origin1[i] == &quot;other&quot; &amp; phdethnicity$origin2[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    }
}</code></pre>
<p>Let’s see what the data looks like. In this case, we see that the two
methods for determining ethnicity (at least with regards to Moroccan vs
non-Moroccan) appear to be in agreement.</p>
<pre class="r test"><code>phdethnicity[, c(1, 2, 5, 9, 11, 6)]</code></pre>
</div>
<div id="method-3-pdf-birth-places" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Method 3: PDF birth
places</h1>
<p>Based on lists of Dutch municipalities, we can establish whether
someone was born in the Netherlands. We use lists of municipalities
provided by Statistics Netherlands from the years
2006/2014/2015/2016/2018/2019/2020/2021, as well as mutations in
municipalities or municipality names during the period of this study
<span class="citation">(<strong>Statistics?</strong>
Netherlands)</span>.</p>
<p>If the birth place info contains a Dutch municipality or a reference
to the Netherlands, a person is born in the Netherlands. If there is a
reference to Turkey, Morocco, the</p>
<pre class="r test"><code># loading in the list of Dutch municipalities
load(file = &quot;data/municipalities/dutch_mun_all.rda&quot;)

# creating strings with indicators for birth countries (The Netherlands, Caribbean Netherlands,
# Turkey, Morocco)
dutch &lt;- c(as.character(dutch_mun$municipality), &quot;netherlands&quot;, &quot;the netherlands&quot;, &quot;nederland&quot;, &quot;\\snl\\s&quot;)

carribean &lt;- c(&quot;suriname&quot;, &quot;nederlandse antillen&quot;, &quot;curacao&quot;, &quot;curaçao&quot;, &quot;bonaire&quot;, &quot;\\sssaba\\s&quot;, &quot;sint eustatius&quot;,
    &quot;sint maarten&quot;, &quot;aruba&quot;)

turkish &lt;- c(&quot;turkije&quot;, &quot;turkey&quot;)

moroccan &lt;- c(&quot;marokko&quot;, &quot;morocco&quot;)



# Origin3: country of birth variable
phdethnicity$origin3 &lt;- ifelse(as.numeric(str_detect(phdethnicity$diss_birthplace, paste(dutch, collapse = &quot;|&quot;))) ==
    1, &quot;dutch&quot;, NA)

phdethnicity$origin3 &lt;- ifelse(as.numeric(str_detect(phdethnicity$diss_birthplace, paste(carribean, collapse = &quot;|&quot;))) ==
    1, &quot;caribbean&quot;, phdethnicity$origin3)

phdethnicity$origin3 &lt;- ifelse(as.numeric(str_detect(phdethnicity$diss_birthplace, paste(turkish, collapse = &quot;|&quot;))) ==
    1, &quot;turkish&quot;, phdethnicity$origin3)

phdethnicity$origin3 &lt;- ifelse(as.numeric(str_detect(phdethnicity$diss_birthplace, paste(moroccan, collapse = &quot;|&quot;))) ==
    1, &quot;moroccan&quot;, phdethnicity$origin3)


phdethnicity$origin3 &lt;- factor(phdethnicity$origin3, levels = c(&quot;dutch&quot;, &quot;caribbean&quot;, &quot;turkish&quot;, &quot;moroccan&quot;))

# Create explicit missing category
phdethnicity &lt;- phdethnicity %&gt;%
    mutate(origin3 = fct_explicit_na(origin3, na_level = &quot;missing&quot;))


# We replace missing or other with &#39;dutch&#39; if a person is born in NL We replace missing, other,
# dutch and moroccan with &#39;turkish&#39; if a person is born in Turkey We replace missing, other, dutch
# and turkish with &#39;moroccan&#39; if a person is born in Morocco

for (i in 1:nrow(phdethnicity)) {
    if (phdethnicity$ethnicity[i] == &quot;missing&quot; &amp; phdethnicity$origin3[i] == &quot;dutch&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;dutch&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;other&quot; &amp; phdethnicity$origin3[i] == &quot;dutch&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;dutch&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;missing&quot; &amp; phdethnicity$origin3[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;dutch&quot; &amp; phdethnicity$origin3[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;other&quot; &amp; phdethnicity$origin3[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;turkish&quot; &amp; phdethnicity$origin3[i] == &quot;moroccan&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;moroccan&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;missing&quot; &amp; phdethnicity$origin3[i] == &quot;turkish&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;turkish&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;dutch&quot; &amp; phdethnicity$origin3[i] == &quot;turkish&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;turkish&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;other&quot; &amp; phdethnicity$origin3[i] == &quot;turkish&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;turkish&quot;
    } else if (phdethnicity$ethnicity[i] == &quot;moroccan&quot; &amp; phdethnicity$origin3[i] == &quot;turkish&quot;) {
        phdethnicity$ethnicity[i] &lt;- &quot;turkish&quot;
    }
}</code></pre>
<p>After all these operations, we are left with an ethnicity object
which is based on origins of last names and first names, and on the
birth place listed in the dissertation.</p>
<p>For these example cases, the labels given based on these different
indicators overlap perfectly, but the code above gives insight in the
heuristics we use to combine potentially conflicting ethnicity
labels.</p>
<pre class="r test"><code>phdethnicity[, c(2, 5, 6, 10, 9, 11, 12)]</code></pre>
</div>
<div id="ethnicity-2" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Ethnicity 2</h1>
<p>Although we need the specific ethnicity labels for our measure of
gender, we use a less-detailed measure of ethnic background for our
analyses. In this measure we distinguish between individuals with an
ethnic majority, ethnic minority (Turkish-Dutch, Moroccan-Dutch,
Caribbean-Dutch) or other ethnic background. This has to do with small
group sizes for each of the specific ethnic minority backgrounds.</p>
<p>We subsume “missing” ethnic background under other ethnic background,
because we believe that it is unlikely that a person with a Dutch
majority, Turkish-Dutch, Moroccan-Dutch or Caribbean-Dutch background
would have gone unnoticed using our array of methods to determine
ethnicity.</p>
<pre class="r test"><code>phdethnicity$ethnicity2 &lt;- phdethnicity$ethnicity

phdethnicity$ethnicity2 &lt;- fct_collapse(phdethnicity$ethnicity2, majority = &quot;dutch&quot;, minority = c(&quot;moroccan&quot;,
    &quot;turkish&quot;, &quot;carribean&quot;), other = c(&quot;other&quot;, &quot;missing&quot;))



phdethnicity &lt;- subset(phdethnicity, select = c(id, firstname, np, lastname, lastname_full, diss_birthplace,
    uni, phd_year, ethnicity, ethnicity2))</code></pre>
<hr />
</div>
<div id="output" class="section level1" number="8">
<h1><span class="header-section-number">8</span> Output</h1>
<pre class="r test"><code>phdethnicity</code></pre>
<hr />
</div>
<div id="references" class="section level1" number="9">
<h1><span class="header-section-number">9</span> References</h1>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkFjYWRlbWljIHB1Ymxpc2hpbmcgY2FyZWVycyBpbiBOTDogZ2F0aGVyaW5nIGV0aG5pY2l0eSINCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWINCmRhdGU6ICJMYXN0IGNvbXBpbGVkIG9uIGByIGZvcm1hdChTeXMudGltZSgpLCAnJUIsICVZJylgIg0Kb3V0cHV0OiANCiAgaHRtbF9kb2N1bWVudDoNCiAgICBjc3M6IHR3ZWFrcy5jc3MNCiAgICB0b2M6ICB0cnVlDQogICAgdG9jX2Zsb2F0OiB0cnVlDQogICAgbnVtYmVyX3NlY3Rpb25zOiB0cnVlDQogICAgY29kZV9mb2xkaW5nOiBzaG93DQogICAgY29kZV9kb3dubG9hZDogeWVzDQotLS0NCg0KPCEtLS1wbGVhc2UgYmUgYXdhcmUgdGhhdCBjYWNoaW5nIGxhcmdlIG9iamVjdHMgaXMgcHJvYmxlbWF0aWMsIGhlbmNlIGNhY2hlLmxhenk9RkFMU0UgYW5kIHlvdSBtYXkgbmVlZCB0byB0dXJuIGNhY2hlPUZBTFNFIGZvciBjaHVuY2tzIGluIHdoaWNoIHlvdSBsb2FkIGxhcmdlIGRhdGFzZXRzIC0tLT4gDQoNCmBgYHtyLCBnbG9iYWxzZXR0aW5ncywgZWNobz1GQUxTRSwgd2FybmluZz1GQUxTRSwgcmVzdWx0cz0iaGlkZSJ9DQpsaWJyYXJ5KGtuaXRyKQ0Kb3B0c19jaHVuayRzZXQodGlkeS5vcHRzPWxpc3Qod2lkdGguY3V0b2ZmPTEwMCksdGlkeT1UUlVFLCB3YXJuaW5nID0gRkFMU0UsIG1lc3NhZ2UgPSBGQUxTRSxjb21tZW50ID0gIiM+IiwgY2FjaGU9VFJVRSwgY2xhc3Muc291cmNlPWMoInRlc3QiKSwgY2xhc3Mub3V0cHV0PWMoInRlc3QyIiksIGNhY2hlLmxhenkgPSBGQUxTRSwgZXZhbD1GQUxTRSkNCm9wdGlvbnMod2lkdGggPSAxMDApDQpyZ2w6OnNldHVwS25pdHIoKQ0KDQpjb2xvcml6ZSA8LSBmdW5jdGlvbih4LCBjb2xvcikge3NwcmludGYoIjxzcGFuIHN0eWxlPSdjb2xvcjogJXM7Jz4lczwvc3Bhbj4iLCBjb2xvciwgeCkgfQ0KDQpgYGANCg0KYGBge3Iga2xpcHB5LCBlY2hvPUZBTFNFLCBpbmNsdWRlPVRSVUV9DQprbGlwcHk6OmtsaXBweShwb3NpdGlvbiA9IGMoJ3RvcCcsICdyaWdodCcpKQ0KI2tsaXBweTo6a2xpcHB5KGNvbG9yID0gJ2RhcmtyZWQnKQ0KI2tsaXBweTo6a2xpcHB5KHRvb2x0aXBfbWVzc2FnZSA9ICdDbGljayB0byBjb3B5JywgdG9vbHRpcF9zdWNjZXNzID0gJ0RvbmUnKQ0KYGBgDQoNCg0KDQoNCi0tLS0NCg0KDQpXZSBkZXRlcm1pbmUgZXRobmljIGJhY2tncm91bmRzIGJhc2VkIG9uIGxhc3QgbmFtZXMuIEZvciB0aGlzLCB3ZSB1c2UgaW5mb3JtYXRpb24gZnJvbSB0aHJlZSBzb3VyY2VzOg0KDQoxLiBEYXRhIG9uIHRoZSBvcmlnaW4gb2YgbGFzdCBuYW1lcywgd2ViIHNjcmFwZWQgZnJvbSB0aGUgW05lZGVybGFuZHNlIEZhbWlsaWVuYW1lbmJhbmtdKGh0dHBzOi8vd3d3LmNiZ2ZhbWlsaWVuYW1lbi5ubC9uZmIvKQ0KDQoyLiBBIGxpc3Qgb2YgY29tbW9uIE1vcm9jY2FuIG5hbWVzDQoNCjMuIEJpcnRoIGNvdW50cmllcyBsaXN0ZWQgaW4gZGlzc2VydGF0aW9uIFBERnMNCg0KDQogIA0KLS0tLQ0KDQojIEN1c3RvbSBmdW5jdGlvbnMNCg0KLSBgZnBhY2thZ2UuY2hlY2tgOiBDaGVjayBpZiBwYWNrYWdlcyBhcmUgaW5zdGFsbGVkIChhbmQgaW5zdGFsbCBpZiBub3QpIGluIFIgKFtzb3VyY2VdKGh0dHBzOi8vdmJhbGlnYS5naXRodWIuaW8vdmVyaWZ5LXRoYXQtci1wYWNrYWdlcy1hcmUtaW5zdGFsbGVkLWFuZC1sb2FkZWQvKSkuICANCg0KDQpgYGB7ciwgcmVzdWx0cz0naGlkZSd9DQoNCnJtKGxpc3QgPSBscygpKQ0KDQoNCmZwYWNrYWdlLmNoZWNrIDwtIGZ1bmN0aW9uKHBhY2thZ2VzKSB7DQogIGxhcHBseShwYWNrYWdlcywgRlVOID0gZnVuY3Rpb24oeCkgew0KICAgIGlmICghcmVxdWlyZSh4LCBjaGFyYWN0ZXIub25seSA9IFRSVUUpKSB7DQogICAgICBpbnN0YWxsLnBhY2thZ2VzKHgsIGRlcGVuZGVuY2llcyA9IFRSVUUpDQogICAgICBsaWJyYXJ5KHgsIGNoYXJhY3Rlci5vbmx5ID0gVFJVRSkNCiAgICB9DQogIH0pDQp9DQoNCmZzYXZlIDwtIGZ1bmN0aW9uKHgsIGZpbGUsIGxvY2F0aW9uPSIuL2RhdGEvcHJvY2Vzc2VkLyIpIHsNCiAgZGF0ZW5hbWUgPC0gc3Vic3RyKGdzdWIoIls6LV0iLCAiIiwgU3lzLnRpbWUoKSksIDEsOCkgIA0KICB0b3RhbG5hbWUgPC0gcGFzdGUobG9jYXRpb24sIGRhdGVuYW1lLCBmaWxlLCBzZXA9IiIpDQogIHNhdmUoeCwgZmlsZSA9IHRvdGFsbmFtZSkgIA0KfQ0KDQpgYGANCg0KLS0tICANCg0KIyBQYWNrYWdlcw0KDQotIGB0aWR5dmVyc2VgOiBGb3IgZ2VuZXJhbCBkYXRhIG1hbmlwdWxhaW9uDQoNCi0gYHN0cmluZ3JgOiBmb3Igc3RyaW5nIG1hbmlwdWxhdGlvbnMNCg0KLSBgZHBseXJgOiBmb3IgZGF0YSBtYW5pcHVsYXRpb24NCg0KLSBgcnZlc3RgOiBmb3IgDQoNCg0KYGBge3IsIHJlc3VsdHM9J2hpZGUnfQ0KDQoNCnBhY2thZ2VzID0gYygidGlkeXZlcnNlIiwgInN0cmluZ3IiLCAiZHBseXIiLCAicnZlc3QiLCAic3RyaW5naSIsICJmb3JjYXRzIikNCg0KZnBhY2thZ2UuY2hlY2socGFja2FnZXMpDQoNCmBgYA0KDQotLS0gDQoNCg0KIyBJbnB1dA0KDQpXZSB1c2UgdHdvIHByb2Nlc3NlZCBkYXRhc2V0cw0KDQoqIFtwaGRuYW1lcy5yZGFdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbW11bGRlcnMvYW1hdHRlcm9mdGltZS9kYXRhL3Byb2Nlc3NlZC9waGRuYW1lcy5yZGEpOiBleGFtcGxlIGRhdGFzZXQgb2YgOCAoZmljdGlvbmFsKSBQaERzIHdpdGggZmlyc3QgYW5kIGxhc3QgbmFtZXMNCiAgICAtIEZvciBjb25zdHJ1Y3Rpb24gb2YgdGhpcyBkYXRhc2V0IHNlZSBbSW5kZXBlbmRlbnQgdmFyaWFibGVzOiBuYW1lc10obmFtZXMuaHRtbCkgIA0KICAgIC0gbmFtZSBvZiBkYXRhc2V0OiBgcGhkbmFtZXNgIA0KDQoqIFtsYXN0bmFtZV9vcmlnaW4ucmRhXShodHRwczovL2dpdGh1Yi5jb20vYW1tdWxkZXJzL2FtYXR0ZXJvZnRpbWUvZGF0YS9wcm9jZXNzZWQvbGFzdG5hbWVfb3JpZ2luLnJkYSk6IHdlYiBzY3JhcGVkIGV0aG5pY2l0eSBkYXRhIGZvciB0aGUgOCBsYXN0IG5hbWVzIGluIHRoZSBleGFtcGxlIGRhdGEgZnJvbSBkZSBOZWRlcmxhbmRzZSBGYW1pbGllbmFtZW5iYW5rDQogICAgLSBuYW1lIG9mIGRhdGFzZXQ6IGBnZW5kZXJgIA0KDQpgYGB7ciBkYXRhc2V0cywgY2FjaGU9RkFMU0V9DQoNCmxvYWQoZmlsZSA9ICIuL2RhdGEvcHJvY2Vzc2VkL3BoZG5hbWVzLnJkYSIpDQoNCmxvYWQoZmlsZSA9ICIuL2RhdGEvcHJvY2Vzc2VkL2xhc3RuYW1lX29yaWdpbi5yZGEiKQ0KDQoNCmBgYA0KDQotLS0gIA0KDQojIE1ldGhvZCAxOiBGYW1pbGllbmFtZW5iYW5rIGxhc3QgbmFtZSBvcmlnaW4NCg0KVGhlIHByaW1hcnkgZGV0ZXJtaW5hbnQgZm9yIGV0aG5pY2l0eSBpcyBbZGUgTmVkZXJsYW5kc2UgRmFtaWxpZW5hbWVuYmFua10oaHR0cHM6Ly93d3cuY2JnZmFtaWxpZW5hbWVuLm5sL25mYi8pKGhlcmVhZnRlciAiRmFtaWxpZW5hbWVuYmFuayIpLiBUaGlzIHdlYnNpdGUsIGxpa2UgdGhlIE1lZXJ0ZW5zIFZvb3JuYW1lbmJhbmsgd2hpY2ggd2FzIHVzZWQgdG8gZGV0ZXJtaW5lIHJlc2VhcmNoZXJzJyBnZW5kZXIsIHVzZXMgcmVnaXN0ZXIgZGF0YSBmcm9tIER1dGNoIGluaGFiaXRhbnRzLiBTcGVjaWZpY2FsbHksIHRoZSB3ZWJzaXRlIGhhcmJvcnMgaW5mb3JtYXRpb24gb24gdGhlIGZyZXF1ZW5jeSwgZ2VvZ3JhcGhpY2FsIHNwcmVhZCwgYW5kIG9yaWdpbiBvZiAzMjAsMDAwIGxhc3QgbmFtZXMgd2hpY2ggb2NjdXIgaW4gdGhlIER1dGNoIHJlZ2lzdGVyLiANCg0KVGhlIG9yaWdpbiBpbmZvcm1hdGlvbiwgc3BlY2lmaWNhbGx5LCBpcyB1c2VkIHRvIGRldGVybWluZSByZXNlYXJjaGVycycgZXRobmljaXRpZXMuIFRoaXMgaW5mb3JtYXRpb24gaXMgZm91bmQgdW5kZXIgdGhlICdhbmFseXNlIGVuIHZlcmtsYXJpbmcnIHRhYiBvZiB0aGUgbmFtZSBwYWdlLiANClRoaXMgaW5mb3JtYXRpb24gaXMgc3RydWN0dXJlZCBzbyB0aGF0LCBpZiBuYW1lcyBhcmUgRHV0Y2gsIG1vcmUgZGV0YWlsZWQgb3JpZ2lucyBvZiB0aGUgbmFtZSBhcmUgbWVudGlvbmVkIChlLmcuIHdoZXRoZXIgdGhlIGxhc3QgbmFtZSBvcmlnaW5hdGVzIGZyb20gYSBjZXJ0YWluIHByb2Zlc3Npb24sIGdlb2dyYXBoaWNhbCByZWdpb24gaW4gdGhlIE5ldGhlcmxhbmRzIG9yIHdoZXRoZXIgaXQgaXMgZGVyaXZlZCBmcm9tIGZhdGhlcnMnIGZpcnN0IG5hbWVzKS4gSWYgbmFtZXMgYXJlIG5vdCBEdXRjaCwgaG93ZXZlciwgb25seSB0aGUgY291bnRyeSBvciBicm9hZGVyIHJlZ2lvbiBmcm9tIHdoaWNoIHRoZSBuYW1lIG9yaWdpbmF0ZXMgaXMgbWVudGlvbmVkLiBTZWUgYmVsb3cgZm9yIGV4YW1wbGVzIG9mIHRoZXNlIHBhZ2VzIGZvciBhIER1dGNoIGFuZCBhIG5vbi1EdXRjaCBsYXN0IG5hbWUuICANCg0KIVt2ZXJzY2h1dXJlbmNiZ10oLi9taXNjL3ZlcnNjaHV1cmVuX2NiZ2YucG5nKQ0KDQohW2thcmltaWNiZ10oLi9taXNjL2thcmltaV9jYmdmLnBuZykNCg0KV2Ugc2NyYXBlZCB0aGUgImFuYWx5c2UgZW4gdmVya2xhcmluZyIgc2VjdGlvbiBmb3IgZWFjaCBvZiB0aGUgbGFzdCBuYW1lcyBpbiBvdXIgc2FtcGxlLiBUaGUgbGF0dGVyIGltYWdlIHNob3dzIHRoYXQgdGhlIHN1YnNlY3Rpb24gInZlcmtsYXJpbmciIGFuZCAia2VubWVya2VuIiBwcm92aWRlIGluZm9ybWF0aW9uIG9uIHRoZSBjb3VudHJpZXMgYXNzb2NpYXRlZCB3aXRoIG5vbi1EdXRjaCBuYW1lcywgd2hpbGUgInNwZWNpZmlla2UgY29tcG9uZW50ZW4iIHByb3ZpZGVzIG1vcmUgaW5mb3JtYXRpb24gb24gY2VydGFpbiBwYXJ0cyBvZiB0aGUgbmFtZS4gVGhlIHJlc3VsdGluZyBkYXRhZnJhbWUgZm9yIG91ciBleGFtcGxlIGRhdGFzZXQgaXMgc2hvd24gYmVsb3cuDQoNCmBgYHtyfQ0KDQpwcmludChsYXN0bmFtZV9vcmlnaW4sIHJvdy5uYW1lcz1GQUxTRSkNCg0KYGBgDQoNCg0KIyMgU2VwYXJhdGluZyBuYW1lcyB3aXRoIER1dGNoICYgdW5rbm93biBvcmlnaW4NCg0KQXMgbWVudGlvbmVkIGVhcmxpZXIsIGl0IGlzIG5vdCBtZW50aW9uZWQgZXhwbGljaXRseSB0aGF0IER1dGNoIG5hbWVzIGFyZSBEdXRjaC4gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGlkZW50aWZ5IER1dGNoIG5hbWVzIHNwZWNpZmljYWxseSwgYW5kIHNldCB0aGVtIGFwYXJ0IGZyb20gbm9uLUR1dGNoIG5hbWVzIGZvciB3aGljaCB0aGVyZSBpcyBubyBvcmlnaW4gaW5mb3JtYXRpb24gcHJlc2VudC4gDQoNCkluIHNob3J0LCB3ZSBkZXRlY3QgdGhlIHR3byBjYXRlZ29yaWVzIG9mIG5hbWVzIGFzIGZvbGxvd3M6DQotIER1dGNoIG5hbWVzOiBubyBsYWJlbCBpbmRpY2F0aW5nIHRoYXQgdGhlIG5hbWUgaXMgRHV0Y2gsIGJ1dCBzb21lIG90aGVyIGluZm9ybWF0aW9uIGF2YWlsYWJsZSBvbiBuYW1lIG9yaWdpbg0KLSBVbmtub3duIG5hbWVzOiB3ZWIgcGFnZSBjYW5ub3QgYmUgZm91bmQsIHNvIG9yaWdpbiBpbmZvcm1hdGlvbiBpcyBjb21wbGV0ZWx5IGVtcHR5LiANCg0KYGBge3Igb3JpZ2luLXVua25vd259DQoNCiMgSWRlbnRpZnkgbGFzdCBuYW1lcyB0aGF0IGNvdWxkIG5vdCBiZSBmb3VuZA0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgbXV0YXRlKHZlcmtsYXJpbmcgPSBpZmVsc2UodmVya2xhcmluZz09IiIsIDAsIHZlcmtsYXJpbmcpLCANCiAgICAgICAgIGtlbm1lcmtlbiA9IGlmZWxzZShrZW5tZXJrZW49PSJjaGFyYWN0ZXIoMCkiLCAwLCBrZW5tZXJrZW4pLA0KICAgICAgICAgc2MgPSBpZmVsc2Uoc2M9PSJjaGFyYWN0ZXIoMCkiLCAwLCBzYyksDQogICAgICAgICBub19pbmZvID0gbmNoYXIodmVya2xhcmluZykgKyBuY2hhcihrZW5tZXJrZW4pICsgbmNoYXIoc2MpKQ0KDQpsYXN0bmFtZV9vcmlnaW4gPC0gbGFzdG5hbWVfb3JpZ2luICU+JQ0KICBtdXRhdGUobm9faW5mbyA9IGlmZWxzZShub19pbmZvPT0zLCAxLCAwKSwgDQogICAgICAgICB2ZXJrbGFyaW5nID0gaWZlbHNlKHZlcmtsYXJpbmc9PTAsIE5BLCB2ZXJrbGFyaW5nKSwNCiAgICAgICAgIGtlbm1lcmtlbiA9IGlmZWxzZShrZW5tZXJrZW49PTAsIE5BLCBrZW5tZXJrZW4pKQ0KIyBJZiB0aGVyZSBpcyBubyB0ZXh0IGluIHZlcmtsYXJpbmcgb3Iga2VubWVya2VuLCB0aGUgbmFtZSBjb3VsZCBub3QgYmUgZm91bmQgaW4gdGhlIGRhdGFiYXNlcy4gDQoNCmBgYA0KDQoNCiMjIEV4dHJhY3Rpbmcgc3BlY2lmaWMgb3JpZ2luIGluZm9ybWF0aW9uDQpUaGVyZSBhcmUgdGhyZWUgbWFpbiB3YXlzIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luIG9mIGxhc3QgbmFtZXM6DQoNCjEpIFVuZGVyICJrZW5tZXJrZW4iLCBsYXN0IG5hbWVzIGFyZSBhc3NpZ25lZCBjbGlja2FibGUgdGFncy4gVGhlc2UgdGFncyBpbmNsdWRlIHVuc3BlY2lmaWVkIGZvcmVpZ24gbmFtZSB0YWdzICgiYW5kZXJlIHRhYWwiPSJub24tRHV0Y2ggbGFuZ3VhZ2UiKSwgYXMgd2VsbCBhcyBzcGVjaWZpYyBmb3JlaWduIG9yaWdpbnMgb2YgdGhlIG5hbWUgKCJGcmFuc2UgbmFhbSI9IkZyZW5jaCBuYW1lIiwgIkluZGlzY2hlIG5hYW0iPSJJbmRvbmVzaWFuIG5hbWUiKS4NCi0+IG9yaWdpbjEgKyBvcmlnaW40DQoNCjIpIFNldmVyYWwgbmFtZXMgaGF2ZSBtb3JlIGV4dGVuc2l2ZWx5IHdyaXR0ZW4gb3V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBuYW1lLCB1bmRlciAidmVya2xhcmluZyIuIEEgbnVtYmVyIG9mIG5hbWVzIGNvbnRhaW4gZGV0YWlsZWQgKGVpdGhlciBjb3VudHJ5LWxldmVsIG9yIHJlZ2lvbmFsKSBvcmlnaW5zLCB1c3VhbGx5IGluIHRoZSBmb3JtIG9mICJEZSBuYWFtIFt4eXpdIGlzIGFma29tc3RpZyB1aXQgW2NvdW50cnldIiAoPSJUaGUgbmFtZSBbeHl6XSBvcmlnaW5hdGVzIGZyb20gW2NvdW50cnldIikuIA0KLT4gb3JpZ2luMiANCg0KMykgU29tZSBuYW1lcyBoYXZlIG9yaWdpbiBpbmZvcm1hdGlvbiB1bmRlciAidmVya2xhcmluZyIgaW4gdGhlIGZvcm0gb2YgdGhlIGxpbmd1aXN0aWMgb3JpZ2lucyBvZiB0aGUgbmFtZS4gVGhpcyBjYW4gYmUgY291bnRyeSBzcGVjaWZpYyAoZS5nLiBDaGluZXNlIG5hbWUpLCBidXQgaXQgY2FuIGFsc28gYXBwbHkgdG8gbXVsdGlwbGUgY291bnRyaWVzIHdoZW4gdGhlIGxhbmd1YWdlIGlzIHNwb2tlbiBpbiBtb3JlIHRoYW4gMSBjb3VudHJpZXMgKGUuZy4gU3BhbmlzaCBuYW1lKS4gDQotPiBvcmlnaW4zIA0KDQpgYGB7ciBjb3VudHJpZXMtZXh0cmFjdH0NCg0KIyBTdGVwIDE6IGV4dHJhY3Rpbmcgb3JpZ2luIHRhZ3MgZnJvbSBrZW5tZXJrZW4NCmxhc3RuYW1lX29yaWdpbiA8LSBsYXN0bmFtZV9vcmlnaW4gJT4lDQogIG11dGF0ZShvcmlnaW4xID0gc3RyX2V4dHJhY3Qoa2VubWVya2VuLCAiWzp1cHBlcjpdKFs6bG93ZXI6XXsyLH0pIG5hYW0iKSkNCg0KIyBOb3RlOiBzb21ldGltZXMgbXVsdGlwbGUgb3JpZ2lucyBhcmUgbWVudGlvbmVkLiBDdXJyZW50bHksIEkgb25seSBleHRyYWN0IHRoZSBmaXJzdCBvbmUuIE90aGVyd2lzZSwgd2Ugc2hvdWxkIHVzZSBzdHJfZXh0cmFjdF9hbGwuIA0KDQoNCg0KIyBTdGVwIDI6IGV4dHJhY3Rpbmcgb3JpZ2luIGluZm8gZnJvbSB2ZXJrbGFyaW5nIA0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgbXV0YXRlKG9yaWdpbjIgPSBpZmVsc2UoYXMubnVtZXJpYyhzdHJfZGV0ZWN0KHZlcmtsYXJpbmcsICJhZmtvbXN0aWcgdWl0IikpID09IDEsIA0KICAgICAgICAgc3RyX3JlbW92ZSh2ZXJrbGFyaW5nLCAiLiphZmtvbXN0aWcgdWl0IiksIE5BKSkNCg0KDQojIFN0ZXAgMzogZXh0cmFjdGluZyBhZGRpdGlvbmFsIG9yaWdpbiBpbmZvIGZyb20gdmVya2xhcmluZw0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgbXV0YXRlKG9yaWdpbjMgPSBzdHJfZXh0cmFjdCh2ZXJrbGFyaW5nLCAiWzp1cHBlcjpdKFs6bG93ZXI6XXsyLH0pIChhY2h0ZXIpPyhmYW1pbGllKT8oYmVyb2Vwcyk/bmFhbSIpKQ0KDQoNCg0KIyBGaW5hbGx5LCB3ZSBjbGVhbiB1cCB0aGUgb3JpZ2luIGluZm9ybWF0aW9uIGV4dHJhY3RlZCBhYm92ZQ0KDQojIE9yaWdpbjE6IGFscmVhZHkgbmVhdA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjEgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMSwgIkpvb2RzZSBuYWFtIikgIyBjYW4gYmUgRHV0Y2ggJiBub24tRHV0Y2gNCg0KIyBPcmlnaW4yOiBtZXNzeQ0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjIgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMiwgIlxcLi4qIikgIyByZW1vdmUgZXh0cmEgaW5mbyBpbiB0aGUgZm9sbG93aW5nIHNlbnRlbmNlIA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjIgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMiwgIlxcOy4qIikgIyByZW1vdmUgZXh0cmEgaW5mbyBpbiB0aGUgZm9sbG93aW5nIHNlbnRlbmNlIA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjIgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMiwgIlxcKC4qIikgIyByZW1vdmUgZXh0cmEgaW5mbyBpbiB0aGUgZm9sbG93aW5nIHNlbnRlbmNlIA0KDQoNCmxhc3RuYW1lX29yaWdpbiRkcGcgPC0gYXMubnVtZXJpYyhzdHJfZGV0ZWN0KGxhc3RuYW1lX29yaWdpbiRvcmlnaW4yLCAiKGRvcnApfChwbGFhdHMpfChnZW1lZW50ZSl8KGdyYWFmc2NoYXApfChzdGFkKXwoZGVlbCl8KEZyaWVzbGFuZCkiKSkgIyBvcmlnaW4gaW5mbyB0b28gcmVnaW9uYWwgDQpsYXN0bmFtZV9vcmlnaW4gPC0gbGFzdG5hbWVfb3JpZ2luICU+JSBtdXRhdGUob3JpZ2luMiA9IGlmZWxzZSgoZHBnPT0xKSwgTkEsIG9yaWdpbjIpKSAjIHJlbW92aW5nIHJlZ2lvbmFsIG9yaWdpbiBpbmZvDQpsYXN0bmFtZV9vcmlnaW4gPC0gc3Vic2V0KGxhc3RuYW1lX29yaWdpbiwgc2VsZWN0ID0gLWRwZykgIyByZW1vdmluZyBpbnRlcm1lZGlhdGUgdmFyaWFibGUNCg0KIyBTb21ldGltZXMsIHRoZXJlIHdlcmUgbXVsdGlwbGUgY291bnRyaWVzIG1lbnRpb25lZC4gVGFrZSBvbmx5IHRoZSBmaXJzdDoNCmxhc3RuYW1lX29yaWdpbiRvcmlnaW4yIDwtIHN0cl9yZW1vdmUobGFzdG5hbWVfb3JpZ2luJG9yaWdpbjIsICJcXCwuKiIpICMgT25seSBmaXJzdA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjIgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMiwgIlxccyhlbikuKiIpICMgT25seSBmaXJzdCANCmxhc3RuYW1lX29yaWdpbiRvcmlnaW4yIDwtIHN0cl9yZW1vdmUobGFzdG5hbWVfb3JpZ2luJG9yaWdpbjIsICJcXHMob2YpLioiKSAjIE9ubHkgZmlyc3QgDQoNCg0KIyBPcmlnaW4zOiBwcmV0dHkgbmVhdA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjMgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMywgIkQoaSk/ZSh6ZSk/IChmYW1pbGllKT8oYWNodGVyKT8oYmVyb2Vwcyk/bmFhbSIpICMgc2xpcHBlZCB0aHJvdWdoIHRoZSByZWdleA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjMgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMywgIkVlbiAoZmFtaWxpZSk/KGFjaHRlcik/KGJlcm9lcHMpP25hYW0iKSAjIHNsaXBwZWQgdGhyb3VnaCB0aGUgcmVnZXgNCmxhc3RuYW1lX29yaWdpbiRvcmlnaW4zIDwtIHN0cl9yZW1vdmUobGFzdG5hbWVfb3JpZ2luJG9yaWdpbjMsICJaaWpuIChmYW1pbGllKT8oYWNodGVyKT8oYmVyb2Vwcyk/bmFhbSIpICMgc2xpcHBlZCB0aHJvdWdoIHRoZSByZWdleA0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjMgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMywgIkFscyAoZmFtaWxpZSk/KGFjaHRlcik/KGJlcm9lcHMpP25hYW0iKSAjIHNsaXBwZWQgdGhyb3VnaCB0aGUgcmVnZXgNCmxhc3RuYW1lX29yaWdpbiRvcmlnaW4zIDwtIHN0cl9yZW1vdmUobGFzdG5hbWVfb3JpZ2luJG9yaWdpbjMsICJKb29kc2UgKGZhbWlsaWUpPyhhY2h0ZXIpP25hYW0iKQ0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjMgPC0gc3RyX3JlbW92ZShsYXN0bmFtZV9vcmlnaW4kb3JpZ2luMywgIkJpamJlbHNlIChmYW1pbGllKT8oYWNodGVyKT9uYWFtIikNCg0KDQojIFNldHRpbmcgZW1wdHkgb3JpZ2luIHZhcmlhYmxlcyB0byBOQSAoRHV0Y2ggb3IgdW5mb3VuZCBmb3JlaWduKQ0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgbXV0YXRlKG9yaWdpbjEgPSBhcy5jaGFyYWN0ZXIoaWZlbHNlKG9yaWdpbjE9PSIifG9yaWdpbjE9PSJjaGFyYWN0ZXIoMCkiLCBOQSwgb3JpZ2luMSkpLA0KICAgICAgICAgb3JpZ2luMiA9IGFzLmNoYXJhY3RlcihpZmVsc2Uob3JpZ2luMj09IiJ8b3JpZ2luMj09ImNoYXJhY3RlcigwKSIsIE5BLCBvcmlnaW4yKSksDQogICAgICAgICBvcmlnaW4zID0gYXMuY2hhcmFjdGVyKGlmZWxzZShvcmlnaW4zPT0iInxvcmlnaW4zPT0iY2hhcmFjdGVyKDApIiwgTkEsIG9yaWdpbjMpKSkNCg0KDQoNCiMgRmluYWxseSwgdGhlIHRhZyAiYW5kZXJlIHRhYWwiIHdhcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGZvcmVpZ24gbmFtZXMgb2YgdW5rbm93biBvcmlnaW4gZnJvbSBrbm93biBEdXRjaCBuYW1lcy4gDQpsYXN0bmFtZV9vcmlnaW4gPC0gbGFzdG5hbWVfb3JpZ2luICU+JQ0KICBtdXRhdGUob3JpZ2luNCA9IGlmZWxzZSgoYXMubnVtZXJpYyhzdHJfZGV0ZWN0KGtlbm1lcmtlbiwgImFuZGVyZSB0YWFsIikpPT0xKSwgIm5vbi1EdXRjaCIsIE5BKSkNCg0KDQpgYGANCg0KDQpUaGUgcmVzdWx0IGlzIGFzIGZvbGxvd3M6DQoNCmBgYHtyfQ0KDQpsYXN0bmFtZV9vcmlnaW5bLGMoMSw2LDcsOCw5KV0NCg0KYGBgDQoNCg0KDQoNCiMjIENvbWJpbmluZyBvcmlnaW4gaW5mbyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzDQoNCk5vdywgd2UgcG90ZW50aWFsbHkgaGF2ZSBvcmlnaW4gaW5mb3JtYXRpb24gZnJvbSB0aHJlZSBkaWZmZXJlbnQgc291cmNlcy4gVGhlIGZpbmFsIG9yaWdpbiBkZWNpc2lvbiBpcyBiYXNlZCBvbiBob3cgZGVwZW5kYWJsZSBhbmQgaG93IGluZm9ybWF0aXZlIHRoZSBsYWJlbCBpcy4gVGhlIGhldXJpc3RpYyBpcyBhcyBmb2xsb3dzOg0KDQoxKSBQcmlvcml0eSBpcyBnaXZlbiB0byBvcmlnaW4gaW5mb3JtYXRpb24gZnJvbSBzcGVjaWZpYyBjb3VudHJ5IHRhZ3MgKGkuZS4gb3JpZ2luMSksIGJlY2F1c2UgdGhpcyBpbmZvcm1hdGlvbiBpcyB0aGUgbW9zdCBuZWF0LiBJZiBubyBjb3VudHJ5IHRhZyBpcyBwcm92aWRlZCB1bmRlciBvcmlnaW4xLCB3ZSBsb29rIGF0IHRoZSBnZW9ncmFwaGljYWwgb3JpZ2lucyBpbmRpY2F0ZWQgaW4gdGhlIHJ1bm5pbmcgdGV4dCAob3JpZ2luIDIpLiBJZiB0aGlzIGlzIGFsc28gbm90IHByZXNlbnQsIHdlIHRha2UgdGhlIGxpbmd1aXN0aWMgb3JpZ2lucyBvZiB0aGUgbmFtZSAob3JpZ2luIDMpIA0KDQoyKSBJZiB0aGVyZSBpcyBubyBzcGVjaWZpYyBjb3VudHJ5IGluZm9ybWF0aW9uLCBidXQgdGhlcmUgaXMgYSB0YWcgZm9yIGEgZm9yZWlnbiBuYW1lIChvcmlnaW40KSwgdGhlbiB0aGUgbmFtZSBpcyBsYWJlbGxlZCBhcyAidW5rbm93biBub24tRHV0Y2giLiANCg0KMykgSWYgdGhlcmUgaXMgbm8gc3BlY2lmaWMgY291bnRyeSBpbmZvcm1hdGlvbiBBTkQgbm8gdGFnIGZvciBmb3JlaWduIG5hbWUgaW4gb3JpZ2luNCwgYnV0IHRoZXJlIGlzIG90aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSBuYW1lLCB3ZSBhc3N1bWUgdGhlIHBlcnNvbiBiZWFyaW5nIHRoaXMgbmFtZSBpcyBEdXRjaC4gDQoNCkluIHN1bTogb3JpZ2luMSA+IG9yaWdpbjIgPiBvcmlnaW4zID4gb3JpZ2luNC4gDQoNCmBgYHtyIGNvbWJpbmluZy1vcmlnaW4xMjN9DQoNCiMgT3JpZ2luIDE6IHNwZWNpZmljIGNvdW50cnkgdGFncyANCmxhc3RuYW1lX29yaWdpbiA8LSBsYXN0bmFtZV9vcmlnaW4gJT4lDQogIG11dGF0ZShvcmlnaW4gPSBvcmlnaW4xKSANCg0KIyBPcmlnaW4gMjogbm8gc3BlY2lmaWMgY291bnRyeSB0YWcsIHRha2UgdGhlIGdlb2dyYXBoaWNhbCBvcmlnaW4gb2YgdGhlIG5hbWUNCmxhc3RuYW1lX29yaWdpbiA8LSBsYXN0bmFtZV9vcmlnaW4gJT4lDQogIG11dGF0ZShvcmlnaW4gPSBpZmVsc2UoKGlzLm5hKG9yaWdpbjEpJiFpcy5uYShvcmlnaW40KSksIG9yaWdpbjIsIG9yaWdpbikpDQoNCiMgT3JpZ2luIDM6IG5laXRoZXIgb2YgdGhlIGFib3ZlLCB0YWtlIHRoZSBsaW5ndWlzdGljIG9yaWdpbiBvZiB0aGUgbmFtZQ0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgIG11dGF0ZShvcmlnaW4gPSBpZmVsc2UoKGlzLm5hKG9yaWdpbjEpJmlzLm5hKG9yaWdpbjIpJiFpcy5uYShvcmlnaW40KSksIG9yaWdpbjMsIG9yaWdpbikpDQoNCiMgT3JpZ2luIDQ6IHNldCB0byB1bmtub3duIG5vbi1EdXRjaCBpZiB0aGUgbmFtZSBpcyBsYWJlbGxlZCBhcyBzdWNoIHdpdGggbm8gc3BlY2lmaWMgb3JpZ2luIGluZm8NCmxhc3RuYW1lX29yaWdpbiA8LSBsYXN0bmFtZV9vcmlnaW4gJT4lDQogICAgbXV0YXRlKG9yaWdpbiA9IGlmZWxzZSgoaXMubmEob3JpZ2luMSkmaXMubmEob3JpZ2luMikmaXMubmEob3JpZ2luMykpLCBvcmlnaW40LCBvcmlnaW4pKQ0KDQojIEZpbmFsIHN0ZXA6IGlmIHRoZXJlIGlzIG5vIG9yaWdpbiBpbmZvcm1hdGlvbiBwcmVzZW50LCBidXQgb3RoZXIgYmFja2dyb3VuZCBpbmZvcm1hdGlvbiBjb3VsZCBiZSBmb3VuZCwgdGhlIG5hbWUgaXMgbGlrZWx5IER1dGNoLg0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgbXV0YXRlKG9yaWdpbiA9IGlmZWxzZSgoaXMubmEob3JpZ2luKSZub19pbmZvPT0wKSwgImR1dGNoIiwgb3JpZ2luKSkNCg0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbiA8LSB0cmltd3MobGFzdG5hbWVfb3JpZ2luJG9yaWdpbiwgd2hpY2ggPSAiYm90aCIpDQoNCmBgYA0KDQoNCg0KVG8gY29uc3RydWN0IHRoZSBldGhuaWNpdHkgdmFyaWFibGUsIHdlIGRpc3Rpbmd1aXNoIGZpdmUgZGlmZmVyZW50IGJhY2tncm91bmRzOg0KMS4gRXRobmljIG1ham9yaXR5IG1lbWJlcnMgKGkuZS4gdGhvc2Ugd2l0aCBEdXRjaCBuYW1lcykNCjIuIFR1cmtpc2gtRHV0Y2ggaW5kaXZpZHVhbHMNCjMuIE1vcm9jY2FuLUR1dGNoIGluZGl2aWR1YWxzDQo0LiBDYXJpYmJlYW4tRHV0Y2ggaW5kaXZpZHVhbHMNCjUuIFRob3NlIHdpdGggYSBkaWZmZXJlbnQgZXRobmljaXR5IGZyb20gdGhvc2UgbGlzdGVkIGFib3ZlDQoNCg0KYGBge3Igb3JpZ2luNWNhdH0NCg0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjEgPC0gbGFzdG5hbWVfb3JpZ2luJG9yaWdpbg0KDQpsYXN0bmFtZV9vcmlnaW4gPC0gc3Vic2V0KGxhc3RuYW1lX29yaWdpbiwgc2VsZWN0ID0gYyhsYXN0bmFtZSwgb3JpZ2luMSkpDQoNCg0KIyB3ZSBkZWZpbmUgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggZXRobmljIG1pbm9yaXR5IG5hbWVzIGFyZSBpZGVudGlmaWVkIGluIHRoZSAiRmFtaWxpZW5hbWVuYmFuayINCmxhc3RuYW1lX29yaWdpbiA8LSBsYXN0bmFtZV9vcmlnaW4gJT4lDQogIG11dGF0ZShvcmlnaW4xID0gaWZlbHNlKGFzLm51bWVyaWMoc3RyX2RldGVjdChvcmlnaW4xLCBwYXN0ZSgiKFR1cmtpamUpfChUdXJrc2UgbmFhbSkiKSkpLCAidHVya2lzaCIsIG9yaWdpbjEpKQ0KDQpsYXN0bmFtZV9vcmlnaW4gPC0gbGFzdG5hbWVfb3JpZ2luICU+JQ0KICBtdXRhdGUob3JpZ2luMSA9IGlmZWxzZShhcy5udW1lcmljKHN0cl9kZXRlY3Qob3JpZ2luMSwgcGFzdGUoIihNYXJva2thYW5zZSBuYWFtKXwoTWFyb2trbyl8KGRlIE1hcm9ra28pIikpKSwgIm1vcm9jY2FuIiwgb3JpZ2luMSkpDQoNCmxhc3RuYW1lX29yaWdpbiA8LSBsYXN0bmFtZV9vcmlnaW4gJT4lDQogIG11dGF0ZShvcmlnaW4xID0gaWZlbHNlKGFzLm51bWVyaWMoc3RyX2RldGVjdChvcmlnaW4xLCBwYXN0ZSgiKGRlIE5lZGVybGFuZHNlIEFudGlsbGVuKXwoU3VyaW5hYW1zZSBuYWFtKXwoU3VyaW5hbWUpIikpKSwgImNhcnJpYmVhbiIsIG9yaWdpbjEpKQ0KDQpsYXN0bmFtZV9vcmlnaW4gPC0gbGFzdG5hbWVfb3JpZ2luICU+JQ0KICBtdXRhdGUob3JpZ2luMSA9IGlmZWxzZSgoIWlzLm5hKG9yaWdpbjEpJmFzLm51bWVyaWMoc3RyX2RldGVjdChvcmlnaW4xLCAidHVya2lzaHxtb3JvY2NhbnxjYXJyaWJlYW58ZHV0Y2giKSk9PTApLCAib3RoZXIiLCBvcmlnaW4xKSkNCg0KbGFzdG5hbWVfb3JpZ2luJG9yaWdpbjEgPC0gYXMuZmFjdG9yKGxhc3RuYW1lX29yaWdpbiRvcmlnaW4xKQ0KICAgICAgDQoNCiMgd2UgY3JlYXRlIGFuIGV4cGxpY2l0ICdtaXNzaW5nJyBjYXRlZ29yeSBmb3IgdGhvc2Ugd2hvIGFyZSBub3QgY2F0ZWdvcml6ZWQgdW5kZXIgZXRobmljIG1ham9yaXR5LCBtaW5vcml0eSBvciAnb3RoZXIgbGFzdG5hbWVfb3JpZ2luJw0KbGFzdG5hbWVfb3JpZ2luIDwtIGxhc3RuYW1lX29yaWdpbiAlPiUNCiAgbXV0YXRlKG9yaWdpbjEgPSBmY3RfZXhwbGljaXRfbmEob3JpZ2luMSwgbmFfbGV2ZWw9Im1pc3NpbmciKSkNCg0KDQojIHRodXMsIHdlIGdldCB0aGUgZm9sbG93aW5nIGRhdGFmcmFtZToNCmxhc3RuYW1lX29yaWdpbg0KDQpgYGANCg0KDQpXZSB0YWtlIHRoZSBsYXN0IG5hbWUgaW5mb3JtYXRpb24gZnJvbSBvcmlnaW4xIGFzIHRoZSBiYXNpcyBmb3Igb3VyIGV0aG5pY2l0eSB2YXJpYWJsZS4gSGVuY2UsIHdlIG1ha2UgYSBuZXcgZGF0YSBmcmFtZSwgaW4gd2hpY2ggd2UgY29weSB0aGUgaW5mb3JtYXRpb24gZnJvbSBvcmlnaW4xIHRvIGEgbmV3ICdldGhuaWNpdHknIG9iamVjdC4gTmV4dCwgd2UgZW5yaWNoIHRoaXMgZXRobmljaXR5IHZhcmlhYmxlIHVzaW5nIGluZm9ybWF0aW9uIGZyb20gZmlyc3QgbmFtZXMgYW5kIGJpcnRoIHBsYWNlcyBsaXN0ZWQgaW4gZGlzc2VydGF0aW9uIFBERnMuIA0KDQpgYGAge3J9DQoNCnBoZGV0aG5pY2l0eSA8LSBsYXN0bmFtZV9vcmlnaW4NCg0KcGhkZXRobmljaXR5JGV0aG5pY2l0eSA8LSBwaGRldGhuaWNpdHkkb3JpZ2luMQ0KDQpgYGANCg0KDQoNCg0KDQoNCiMgTWV0aG9kIDI6IE1vcm9jY2FuIG5hbWUgbGlzdA0KDQoNCkluIGFkZGl0aW9uIHRvIGRldGVybWluaW5nIGV0aG5pY2l0eSBiYXNlZCBvbiBsYXN0IG5hbWVzLCB3ZSBsb29rIGF0IGZpcnN0IG5hbWVzLiBTcGVjaWZpY2FsbHksIHdlIHVzZSBhIGxpc3Qgb2YgTW9yb2NjYW4gZmlyc3QgbmFtZXMgdG8gZGV0ZWN0IHdoZXRoZXIgYW4gaW5kaXZpZHVhbCBpcyBsaWtlbHkgb2YgTW9yb2NjYW4gZGVzY2VudC4gVW50aWxsIHZlcnkgcmVjZW50bHksIGZpcnN0IG5hbWVzIG9mIE1vcm9jY2FuIGluZGl2aWR1YWxzIHdlcmUgcmVndWxhdGVkIGJ5IE1vcm9jY2FuIGxhdyBbQGhhc2tvdXJpXS4gVGhpcyBpbXBsaWVzIHRoYXQgbWFueSBNb3JvY2NhbiBpbmRpdmlkdWFscyBjaG9vc2UgbmFtZXMgZm9yIHRoZWlyIGNoaWxkcmVuIGZyb20gYSBsaXN0IG9mIGFjY2VwdGVkIGdpcmxzIGFuZCBib3lzIG5hbWVzLiBXZSBsb2FkIGluIGEgbGlzdCBvZiBuYW1lcyBieSBAYE1vcm9jY28gR3VpZGVgIGFzIGFuIGFkZGl0aW9uYWwgaW5kaWNhdG9yIHRoYXQgYSBQaEQgaXMgTW9yb2NjYW4gYW5kIGFkZCB0aGlzIHRvIG91ciBleGFtcGxlIGRhdGEgZnJhbWUuIA0KDQoNCmBgYHtyfQ0KDQojIEFkZGluZyBmaXJzdCBuYW1lcyBiYWNrIGluDQpwaGRldGhuaWNpdHkgPC0gbGVmdF9qb2luKHBoZG5hbWVzLCBwaGRldGhuaWNpdHksIGJ5ID0gImxhc3RuYW1lIikNCg0KDQojIEFkZCB0aGUgbW9yb2NjYW4gbmFtZXMgdG8gdGhlIGV0aG5pY2l0eSBkYXRhDQpsb2FkKGZpbGUgPSAiZGF0YS9wcm9jZXNzZWQvbW9yb2NjYW5uYW1lcy5yZGEiKQ0KDQoNCnBoZGV0aG5pY2l0eSA8LSBsZWZ0X2pvaW4ocGhkZXRobmljaXR5LCBtb3JvY2Nhbm5hbWVzWyxjKDEsMyldLCBieSA9ICJmaXJzdG5hbWUiKQ0KDQoNCiMgQWRkIGV4cGxpY2l0IG1pc3NpbmcgY2F0ZWdvcnkgaW4gb3JpZ2luMg0KcGhkZXRobmljaXR5IDwtIHBoZGV0aG5pY2l0eSAlPiUNCiAgbXV0YXRlKG9yaWdpbjIgPSBmY3RfZXhwbGljaXRfbmEob3JpZ2luMiwgbmFfbGV2ZWw9Im1pc3NpbmciKSkNCg0KIyBXZSBvdmVyd3JpdGUgZXRobmljaXR5IHRvIG1pbm9yaXR5IGlmIHRoZSBmaXJzdCBuYW1lIGlzIE1vcm9jY2FuDQpmb3IgKGkgaW4gMTpucm93KHBoZGV0aG5pY2l0eSkpIHsNCiAgaWYgKHBoZGV0aG5pY2l0eSRvcmlnaW4xW2ldPT0ibWlzc2luZyIgJiBwaGRldGhuaWNpdHkkb3JpZ2luMltpXT09Im1vcm9jY2FuIikgew0KICAgIHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV0gPC0gIm1vcm9jY2FuIg0KICB9IGVsc2UgaWYgKHBoZGV0aG5pY2l0eSRvcmlnaW4xW2ldPT0iZHV0Y2giICYgcGhkZXRobmljaXR5JG9yaWdpbjJbaV09PSJtb3JvY2NhbiIpIHsNCiAgICBwaGRldGhuaWNpdHkkZXRobmljaXR5W2ldIDwtICJtb3JvY2NhbiINCiAgfSBlbHNlIGlmIChwaGRldGhuaWNpdHkkb3JpZ2luMVtpXT09Im90aGVyIiAmIHBoZGV0aG5pY2l0eSRvcmlnaW4yW2ldPT0ibW9yb2NjYW4iKSB7DQogICAgcGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXSA8LSAibW9yb2NjYW4iDQogIH0gDQp9DQoNCmBgYA0KDQoNCkxldCdzIHNlZSB3aGF0IHRoZSBkYXRhIGxvb2tzIGxpa2UuIEluIHRoaXMgY2FzZSwgd2Ugc2VlIHRoYXQgdGhlIHR3byBtZXRob2RzIGZvciBkZXRlcm1pbmluZyBldGhuaWNpdHkgKGF0IGxlYXN0IHdpdGggcmVnYXJkcyB0byBNb3JvY2NhbiB2cyBub24tTW9yb2NjYW4pIGFwcGVhciB0byBiZSBpbiBhZ3JlZW1lbnQuIA0KDQpgYGB7cn0NCg0KcGhkZXRobmljaXR5WyxjKDEsMiw1LDksMTEsNildDQoNCmBgYA0KDQoNCg0KIyBNZXRob2QgMzogUERGIGJpcnRoIHBsYWNlcw0KDQpCYXNlZCBvbiBsaXN0cyBvZiBEdXRjaCBtdW5pY2lwYWxpdGllcywgd2UgY2FuIGVzdGFibGlzaCB3aGV0aGVyIHNvbWVvbmUgd2FzIGJvcm4gaW4gdGhlIE5ldGhlcmxhbmRzLiBXZSB1c2UgbGlzdHMgb2YgbXVuaWNpcGFsaXRpZXMgcHJvdmlkZWQgYnkgU3RhdGlzdGljcyBOZXRoZXJsYW5kcyBmcm9tIHRoZSB5ZWFycyAyMDA2LzIwMTQvMjAxNS8yMDE2LzIwMTgvMjAxOS8yMDIwLzIwMjEsIGFzIHdlbGwgYXMgbXV0YXRpb25zIGluIG11bmljaXBhbGl0aWVzIG9yIG11bmljaXBhbGl0eSBuYW1lcyBkdXJpbmcgdGhlIHBlcmlvZCBvZiB0aGlzIHN0dWR5IFtAU3RhdGlzdGljcyBOZXRoZXJsYW5kc10uDQoNCklmIHRoZSBiaXJ0aCBwbGFjZSBpbmZvIGNvbnRhaW5zIGEgRHV0Y2ggbXVuaWNpcGFsaXR5IG9yIGEgcmVmZXJlbmNlIHRvIHRoZSBOZXRoZXJsYW5kcywgYSBwZXJzb24gaXMgYm9ybiBpbiB0aGUgTmV0aGVybGFuZHMuIElmIHRoZXJlIGlzIGEgcmVmZXJlbmNlIHRvIFR1cmtleSwgTW9yb2NjbywgdGhlDQoNCmBgYHtyfQ0KDQojIGxvYWRpbmcgaW4gdGhlIGxpc3Qgb2YgRHV0Y2ggbXVuaWNpcGFsaXRpZXMNCmxvYWQoZmlsZSA9ICJkYXRhL211bmljaXBhbGl0aWVzL2R1dGNoX211bl9hbGwucmRhIikNCg0KIyBjcmVhdGluZyBzdHJpbmdzIHdpdGggaW5kaWNhdG9ycyBmb3IgYmlydGggY291bnRyaWVzIChUaGUgTmV0aGVybGFuZHMsIENhcmliYmVhbiBOZXRoZXJsYW5kcywgVHVya2V5LCBNb3JvY2NvKQ0KZHV0Y2ggPC0gYyhhcy5jaGFyYWN0ZXIoZHV0Y2hfbXVuJG11bmljaXBhbGl0eSksICJuZXRoZXJsYW5kcyIsICJ0aGUgbmV0aGVybGFuZHMiLCAibmVkZXJsYW5kIiwiXFxzbmxcXHMiKQ0KDQpjYXJyaWJlYW4gPC0gYygic3VyaW5hbWUiLCAibmVkZXJsYW5kc2UgYW50aWxsZW4iLCAiY3VyYWNhbyIsICJjdXJhw6dhbyIsICJib25haXJlIiwgIlxcc3NzYWJhXFxzIiwgInNpbnQgZXVzdGF0aXVzIiwgInNpbnQgbWFhcnRlbiIsICJhcnViYSIpDQoNCnR1cmtpc2ggPC0gYygidHVya2lqZSIsICJ0dXJrZXkiKQ0KDQptb3JvY2NhbiA8LSBjKCJtYXJva2tvIiwgIm1vcm9jY28iKQ0KDQoNCg0KIyBPcmlnaW4zOiBjb3VudHJ5IG9mIGJpcnRoIHZhcmlhYmxlDQpwaGRldGhuaWNpdHkkb3JpZ2luMyA8LSBpZmVsc2UoYXMubnVtZXJpYyhzdHJfZGV0ZWN0KHBoZGV0aG5pY2l0eSRkaXNzX2JpcnRocGxhY2UsIHBhc3RlKGR1dGNoLCBjb2xsYXBzZSA9ICJ8IikpKT09MSwgImR1dGNoIiwgTkEpDQoNCnBoZGV0aG5pY2l0eSRvcmlnaW4zIDwtIGlmZWxzZShhcy5udW1lcmljKHN0cl9kZXRlY3QocGhkZXRobmljaXR5JGRpc3NfYmlydGhwbGFjZSwgcGFzdGUoY2FycmliZWFuLCBjb2xsYXBzZSA9ICJ8IikpKT09MSwgImNhcmliYmVhbiIsIHBoZGV0aG5pY2l0eSRvcmlnaW4zKQ0KDQpwaGRldGhuaWNpdHkkb3JpZ2luMyA8LSBpZmVsc2UoYXMubnVtZXJpYyhzdHJfZGV0ZWN0KHBoZGV0aG5pY2l0eSRkaXNzX2JpcnRocGxhY2UsIHBhc3RlKHR1cmtpc2gsIGNvbGxhcHNlID0gInwiKSkpPT0xLCAidHVya2lzaCIsIHBoZGV0aG5pY2l0eSRvcmlnaW4zKQ0KDQpwaGRldGhuaWNpdHkkb3JpZ2luMyA8LSBpZmVsc2UoYXMubnVtZXJpYyhzdHJfZGV0ZWN0KHBoZGV0aG5pY2l0eSRkaXNzX2JpcnRocGxhY2UsIHBhc3RlKG1vcm9jY2FuLCBjb2xsYXBzZSA9ICJ8IikpKT09MSwgIm1vcm9jY2FuIiwgcGhkZXRobmljaXR5JG9yaWdpbjMpDQoNCg0KcGhkZXRobmljaXR5JG9yaWdpbjMgPC0gZmFjdG9yKHBoZGV0aG5pY2l0eSRvcmlnaW4zLCBsZXZlbHM9YygiZHV0Y2giLCAiY2FyaWJiZWFuIiwgInR1cmtpc2giLCAibW9yb2NjYW4iKSkNCg0KIyBDcmVhdGUgZXhwbGljaXQgbWlzc2luZyBjYXRlZ29yeQ0KcGhkZXRobmljaXR5IDwtIHBoZGV0aG5pY2l0eSAlPiUNCiAgbXV0YXRlKG9yaWdpbjMgPSBmY3RfZXhwbGljaXRfbmEob3JpZ2luMywgbmFfbGV2ZWw9Im1pc3NpbmciKSkNCg0KDQojIFdlIHJlcGxhY2UgbWlzc2luZyBvciBvdGhlciB3aXRoICJkdXRjaCIgaWYgYSBwZXJzb24gaXMgYm9ybiBpbiBOTA0KIyBXZSByZXBsYWNlIG1pc3NpbmcsIG90aGVyLCBkdXRjaCBhbmQgbW9yb2NjYW4gd2l0aCAidHVya2lzaCIgaWYgYSBwZXJzb24gaXMgYm9ybiBpbiBUdXJrZXkNCiMgV2UgcmVwbGFjZSBtaXNzaW5nLCBvdGhlciwgZHV0Y2ggYW5kIHR1cmtpc2ggd2l0aCAibW9yb2NjYW4iIGlmIGEgcGVyc29uIGlzIGJvcm4gaW4gTW9yb2Njbw0KDQpmb3IgKGkgaW4gMTpucm93KHBoZGV0aG5pY2l0eSkpIHsNCiAgaWYgKHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV09PSJtaXNzaW5nIiAmIHBoZGV0aG5pY2l0eSRvcmlnaW4zW2ldPT0iZHV0Y2giKSB7DQogICAgcGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXSA8LSAiZHV0Y2giDQogIH0gZWxzZSBpZiAocGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXT09Im90aGVyIiAmIHBoZGV0aG5pY2l0eSRvcmlnaW4zW2ldPT0iZHV0Y2giKSB7DQogICAgcGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXSA8LSAiZHV0Y2giDQogICAgfSBlbHNlIGlmIChwaGRldGhuaWNpdHkkZXRobmljaXR5W2ldPT0ibWlzc2luZyIgJiBwaGRldGhuaWNpdHkkb3JpZ2luM1tpXT09Im1vcm9jY2FuIikgew0KICAgIHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV0gPC0gIm1vcm9jY2FuIg0KICB9IGVsc2UgaWYgKHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV09PSJkdXRjaCIgJiBwaGRldGhuaWNpdHkkb3JpZ2luM1tpXT09Im1vcm9jY2FuIikgew0KICAgIHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV0gPC0gIm1vcm9jY2FuIg0KICB9IGVsc2UgaWYgKHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV09PSJvdGhlciIgJiBwaGRldGhuaWNpdHkkb3JpZ2luM1tpXT09Im1vcm9jY2FuIikgew0KICAgIHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV0gPC0gIm1vcm9jY2FuIg0KICB9IGVsc2UgaWYgKHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV09PSJ0dXJraXNoIiAmIHBoZGV0aG5pY2l0eSRvcmlnaW4zW2ldPT0ibW9yb2NjYW4iKSB7DQogICAgcGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXSA8LSAibW9yb2NjYW4iDQogIH0gZWxzZSBpZiAocGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXT09Im1pc3NpbmciICYgcGhkZXRobmljaXR5JG9yaWdpbjNbaV09PSJ0dXJraXNoIikgew0KICAgIHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV0gPC0gInR1cmtpc2giDQogIH0gZWxzZSBpZiAocGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXT09ImR1dGNoIiAmIHBoZGV0aG5pY2l0eSRvcmlnaW4zW2ldPT0idHVya2lzaCIpIHsNCiAgICBwaGRldGhuaWNpdHkkZXRobmljaXR5W2ldIDwtICJ0dXJraXNoIg0KICB9IGVsc2UgaWYgKHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV09PSJvdGhlciIgJiBwaGRldGhuaWNpdHkkb3JpZ2luM1tpXT09InR1cmtpc2giKSB7DQogICAgcGhkZXRobmljaXR5JGV0aG5pY2l0eVtpXSA8LSAidHVya2lzaCINCiAgfSBlbHNlIGlmIChwaGRldGhuaWNpdHkkZXRobmljaXR5W2ldPT0ibW9yb2NjYW4iICYgcGhkZXRobmljaXR5JG9yaWdpbjNbaV09PSJ0dXJraXNoIikgew0KICAgIHBoZGV0aG5pY2l0eSRldGhuaWNpdHlbaV0gPC0gInR1cmtpc2giDQogIH0gDQp9DQoNCmBgYA0KDQoNCg0KQWZ0ZXIgYWxsIHRoZXNlIG9wZXJhdGlvbnMsIHdlIGFyZSBsZWZ0IHdpdGggYW4gZXRobmljaXR5IG9iamVjdCB3aGljaCBpcyBiYXNlZCBvbiBvcmlnaW5zIG9mIGxhc3QgbmFtZXMgYW5kIGZpcnN0IG5hbWVzLCBhbmQgb24gdGhlIGJpcnRoIHBsYWNlIGxpc3RlZCBpbiB0aGUgZGlzc2VydGF0aW9uLiANCg0KRm9yIHRoZXNlIGV4YW1wbGUgY2FzZXMsIHRoZSBsYWJlbHMgZ2l2ZW4gYmFzZWQgb24gdGhlc2UgZGlmZmVyZW50IGluZGljYXRvcnMgb3ZlcmxhcCBwZXJmZWN0bHksIGJ1dCB0aGUgY29kZSBhYm92ZSBnaXZlcyBpbnNpZ2h0IGluIHRoZSBoZXVyaXN0aWNzIHdlIHVzZSB0byBjb21iaW5lIHBvdGVudGlhbGx5IGNvbmZsaWN0aW5nIGV0aG5pY2l0eSBsYWJlbHMuIA0KDQpgYGB7cn0NCg0KcGhkZXRobmljaXR5WyxjKDIsNSw2LDEwLDksMTEsMTIpXQ0KDQpgYGANCg0KDQoNCiMgRXRobmljaXR5IDINCg0KQWx0aG91Z2ggd2UgbmVlZCB0aGUgc3BlY2lmaWMgZXRobmljaXR5IGxhYmVscyBmb3Igb3VyIG1lYXN1cmUgb2YgZ2VuZGVyLCB3ZSB1c2UgYSBsZXNzLWRldGFpbGVkIG1lYXN1cmUgb2YgZXRobmljIGJhY2tncm91bmQgZm9yIG91ciBhbmFseXNlcy4gSW4gdGhpcyBtZWFzdXJlIHdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW5kaXZpZHVhbHMgd2l0aCBhbiBldGhuaWMgbWFqb3JpdHksIGV0aG5pYyBtaW5vcml0eSAgKFR1cmtpc2gtRHV0Y2gsIE1vcm9jY2FuLUR1dGNoLCBDYXJpYmJlYW4tRHV0Y2gpIG9yIG90aGVyIGV0aG5pYyBiYWNrZ3JvdW5kLiBUaGlzIGhhcyB0byBkbyB3aXRoIHNtYWxsIGdyb3VwIHNpemVzIGZvciBlYWNoIG9mIHRoZSBzcGVjaWZpYyBldGhuaWMgbWlub3JpdHkgYmFja2dyb3VuZHMuIA0KDQpXZSBzdWJzdW1lICJtaXNzaW5nIiBldGhuaWMgYmFja2dyb3VuZCB1bmRlciBvdGhlciBldGhuaWMgYmFja2dyb3VuZCwgYmVjYXVzZSB3ZSBiZWxpZXZlIHRoYXQgaXQgaXMgdW5saWtlbHkgdGhhdCBhIHBlcnNvbiB3aXRoIGEgRHV0Y2ggbWFqb3JpdHksIFR1cmtpc2gtRHV0Y2gsIE1vcm9jY2FuLUR1dGNoIG9yIENhcmliYmVhbi1EdXRjaCBiYWNrZ3JvdW5kIHdvdWxkIGhhdmUgZ29uZSB1bm5vdGljZWQgdXNpbmcgb3VyIGFycmF5IG9mIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIGV0aG5pY2l0eS4gDQoNCmBgYHtyfQ0KDQpwaGRldGhuaWNpdHkkZXRobmljaXR5MiA8LSBwaGRldGhuaWNpdHkkZXRobmljaXR5DQoNCnBoZGV0aG5pY2l0eSRldGhuaWNpdHkyIDwtIGZjdF9jb2xsYXBzZShwaGRldGhuaWNpdHkkZXRobmljaXR5MiwNCiAgICAgICAgICAgICBtYWpvcml0eSA9ICJkdXRjaCIsDQogICAgICAgICAgICAgbWlub3JpdHkgPSBjKCJtb3JvY2NhbiIsICJ0dXJraXNoIiwgImNhcnJpYmVhbiIpLA0KICAgICAgICAgICAgIG90aGVyID0gYygib3RoZXIiLCAibWlzc2luZyIpKQ0KDQoNCg0KcGhkZXRobmljaXR5IDwtIHN1YnNldChwaGRldGhuaWNpdHksIHNlbGVjdD1jKGlkLCBmaXJzdG5hbWUsIG5wLCBsYXN0bmFtZSwgbGFzdG5hbWVfZnVsbCwgZGlzc19iaXJ0aHBsYWNlLCB1bmksIHBoZF95ZWFyLCBldGhuaWNpdHksIGV0aG5pY2l0eTIpKQ0KDQpgYGANCg0KDQoNCi0tLSANCg0KIyBPdXRwdXQNCg0KDQpgYGB7ciwgZXZhbD1GQUxTRX0NCg0KDQpwaGRldGhuaWNpdHkNCg0KYGBgDQoNCg0KYGBge3IsIGV2YWw9RkFMU0UsIGVjaG89RkFMU0V9DQoNCnNhdmUocGhkZXRobmljaXR5LCBmaWxlID0gIi4vZGF0YS9wcm9jZXNzZWQvcGhkZXRobmljaXR5LnJkYSIpDQoNCmBgYA0KDQoNCg0KLS0tICANCg0KIyBSZWZlcmVuY2VzDQoNCg0K</div>
<style>
  .center {
    text-align: center;
    color: red;
  }
</style>
  
  <hr>
  <br>
  <p class="center">Copyright &copy; 2023 </p>
    


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("ethnicity.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
